## funct = 00 then keyExp, 01 the enc, 11 then dec
"00011100000000010000000000100011", # #lw r1, 35(r0) :r1 gets mem(r0 + 35) = funct
"00101000000000010000000001111110",   #126    #beq r1, r0, #keyExp instruction start jump offset
"00000100000000100000000000000011", ##addi r2, r0, 0x3
"00101000010000010000000000111001",  #57             ##beq r1, r2, #decrypt instruction start jump offset 

##encrypt instructions start here
"00011100000000010000000000000000", #lw r1, 0(r0)	:r1 <- MEM(r0 + 0) base addr = 0 #encrypt instructions start here
"00000100000000100000000000001100", #addi r2, r0, 0xc	:load r = 12
"00011100001000110000000000000011", #lw r3, 3(r1)	:r3 gets A
"00011100001001000000000000000100", #lw r4, 4(r1)	:r4 gets B
"00011100001001010000000000000101", #lw r5, 5(r1)	:r5 gets s(0)
"00011100001001100000000000000110", #lw r6, 6(r1)	:load s(1)
"00000000011001010001100000010000", #add r3, r3, r5	:A + s(0)
"00000000100001100010000000010000", #add r4, r4, r6	:B + s(1)
"00011100000001110000000000000001", #lw r7, 6(r0) 	:r7 gets 6, base addr for s(2)
"00000001101000000110100000010000", #add r13, r13, r0			
"00000000011000110100000000010100", #nor r8, r3, r3	:r8 gets -A
"00000000100001000100100000010100", #nor r9, r4, r4	:r9 gets -B
"00000000011010010101000000010010", #and r10, r3, r9	:r10 gets A.-B
"00000000100010000101100000010010", #and r11, r4, r8	:r11 gets -A.B
"00000001010010110110000000010011", #or r12, r10, r11	:r12 gets A Xor B
"00001100100011010000000000011111", #andi r13, r4, 0x1f   :r13 gets last 5 bits of B
"00101000000011010000000000000111", #beq r13, r0, skip
"00000000000011000111000000010011", #or r14, r0, r12 	:r14 <- r12
"00000000000011000111100000010011", #or r15, r0, r12 	:r15 <- r12
"00010101110011100000000000000001", #shl r14, r14, 1	:Left Shift r14 by 1
"00011001111011110000000000011111", #shr r15, r15, 0x1f	:Right Shift r15 by 31
"00000001110011110110000000010011", #or r12, r14, r15	:r12 gets r12 rotated by B bits
"00001001101011010000000000000001", #subi r13, r13, 1	# r13 gets r13 - 1
"00101100000011011111111111111000", #branch
"11111100000000000000000000000000", #halt									
"00011100111001010000000000000001", #lw r5, 1(r7)	:r5 gets S(2i)
"00000001100001010110000000010000", #add r12, r12, r5	:r12 gets (A Xor B) << B + S(2i) = Anew
"00000001100011000100000000010100", #nor r8, r12, r12 	:r8 gets -A new
"00000001100010010101000000010010", #and r10, r12, r9	:r10 gets Anew.-B
"00000000100010000101100000010010", #and r11, r4, r8	:r11 gets -Anew.B
"00000001010010111000000000010011", #or r16, r10, r11	# r16 gets Anew Xor B 
"00001101100011010000000000011111", #andi r13, r12, 0x1f	:r13 <- Last 5 bits of Anew
"00101000000011010000000000000111", #beq r13, r0, skip2
"00000000000100000111000000010011", #or r14, r0, r16 	:r14 <- r16
"00000000000100000111100000010011", #or r15, r0, r16 	:r15 <- r16
"00010101110011100000000000000001", #shl r14, r14, 1	:Left Shift r14 by 1
"00011001111011110000000000011111", #shr r15, r15, 0x1f	:Right Shift r15 by 31			
"00000001110011111000000000010011", #or r16, r14, r15	:r16 <- r16 rotated by 1 bit
"00001001101011010000000000000001", #subi r13, r13, 1   :r13 gets r13 - 1
"00101100000011011111111111111000", #branch
"11111100000000000000000000000000", #halt										
"00011100111001100000000000000010", #lw r6, 0x8(r7)	:r6 gets S(2i + 1)
"00000010000001101000000000010000", #add r16, r16, r6	:r16 gets (A Xor B) << Anew + S(2i + 1) = Bnew
"00000001100000000001100000010011", #or r3, r12, r0 	:r3 gets new A
"00000010000000000010000000010011", #or r4, r16, r0 	:r4 gets new B
"00000100111001110000000000000010", #addi r7, r7, 2	:Update base address pointer of skey
"00001000010000100000000000000001", #subi r2, r2, 1	:Decrementing r
"00101100000000101111111111011001", #Branch, Compare r2 with 0 and perform 12 iterations
"11111100000000000000000000000000", #halt
"00100000001000110000000000000011", #sw r3, 3(r1)  :Store encrypted A back in same location
"00100000001001000000000000000100", #sw r4, 4(r1)   :Store encrypted B back

"00011100000000010000000000100011",# #lw r1, 35(r0) :r1 gets mem(r0 + 35) = funct
"00101000000000010000000001101100",   #108              ##beq r1, r0, #keyExp instruction start jump offset
"00000100000000100000000000000011", ##addi r2, r0, 0x3
"00101000010000010000000000111000",  #56               ##beq r1, r2, #decrypt instruction start jump offset 
"00101100001000101111111111111010",   #bne r1, r2, 6 #bne r1, r2, load funct again and check
"11111100000000000000000000000000", #halt

##decrypt instructions start here
"00011100000100100000000000000000", # lw r18, 0(r0)    
"00000100000000010000000000001100",#addiu r1, r0, 0xc
"00011110010000110000000000000100",#lw r3, 4(r18)
"00011110010000100000000000000011",#lw r2, 3(r18)
"00011100000001100000000000000010",#lw r6, 2 (r0)
"00001101100011000000000000000000",#andi r12, r12, 0x00000000
"00011100110001011111111111111111",#lw r5, -1(r6)
"00000000011001010011100000010001",#sub r7, r3, r5
"00001100010011000000000000011111",#andi r12, r2, 0x0000001f
"00101000000011000000000000000111", ##beq r12,r0,7
"00000000000001110110100000010011",#or r13, r0, r7
"00000000000001110111000000010011",#or r14, r0, r7 
"00011001101011010000000000000001",#srl r13, r13, 1
"00010101110011100000000000011111",#sll r14, r14, 0x1f
"00000001101011100011100000010011",#or r7, r13, r14	
"00001001100011000000000000000001",#subi r12, r12, 1
"00101100000011001111111111111000",#bne r12, r0, rot1
"11111100000000000000000000000000", #halt
"00000000010000100100000000010100",#nor r8, r2, r2
"00000000111001110100100000010100",#nor r9, r7, r7
"00000000010010010101000000010010",#and r10, r2, r9
"00000000111010000101100000010010",#and r11, r7, r8
"00000001010010110111100000010011",#or r15, r10, r11
"00011100110001001111111111111110",#lw r4, -2(r6)
"00000000010001001000000000010001",#sub r16, r2, r4	
"00001101111011000000000000011111",#andi r12, r15, 0x0000001f
"00101000000011000000000000000111",# #beq r12 r0 7 
"00000000000100000110100000010011",#or r13, r0, r16 
"00000000000100000111000000010011",#or r14, r0, r16
"00011001101011010000000000000001",#srl r13, r13, 1	
"00010101110011100000000000011111",#sll r14, r14, 0x1f
"00000001101011101000000000010011",#or r16, r13, r14
"00001001100011000000000000000001", #subi r12, r12, 1
"00101100000011001111111111111000",#bne r12, r0, rot2	
"11111100000000000000000000000000",#halt
"00000010000100000100000000010100",#nor r8, r16, r16
"00000001111011110100100000010100",#nor r9, r15, r15
"00000010000010010101000000010010",#and r10, r16, r9
"00000001000011110101100000010010",	#and r11, r8, r15		
"00000001010010111000100000010011",#or r17, r10, r11
"00000001111000000001100000010011",#or r3, r15, r0
"00000010001000000001000000010011",#or r2, r17, r0
"00001000110001100000000000000010",#subi r6, r6, 2
"00001000001000010000000000000001",#subi  r1, r1, 1	
"00101100001000001111111111011000",#bne r1, r0, loop	
"11111100000000000000000000000000",#halt
"00011110010001000000000000000101",#lw  r4, 5(r18)
"00011110010001010000000000000110",#lw r5, 6(r18)
"00000000010001000001000000010001",#sub r2, r2, r4
"00000000011001010001100000010001",#sub r3, r3, r5	
"00100010010000100000000000000011",#sw r2, 3(r18) 
"00100010010000110000000000000100",#sw r3, 4(r18)

"00011100000000010000000000100011", # #lw r1, 35(r0) :r1 gets mem(r0 + 35) = funct
"00101000000000010000000001101100",   #108              ##beq r1, r0, #keyExp instruction start jump offset
"00000100000000100000000000000011", ##addi r2, r0, 0x3
"00101000010000010000000000111000",  #56               ##beq r1, r2, #decrypt instruction start jump offset 
"00101100001000101111111111111010",   #bne r1, r2, 6 #bne r1, r2, load funct again and check
"11111100000000000000000000000000", #halt